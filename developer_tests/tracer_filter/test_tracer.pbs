#!/bin/bash
#PBS -N test_tracer
#PBS -j oe
#PBS -l walltime=01:00:00
## PBS_ARRAY_INDEX range, inclusive: (can be overridden by qsub command line arguments)
#PBS -J 0-3
#PBS -r y

echo " --------------------------------------"
echo " Starting ... at YYYY MM DD HH MM SS ="
dt=$(date '+%Y %m %d %H %M %S');
echo "                 $dt"
echo " Program test_tracer"
echo " --------------------------------------"

## Determine the number of nodes, and processors per node we were assigned
## (inferred based on select statement)
nodeslist=( $(cat ${PBS_NODEFILE} | sort | uniq | cut -d'.' -f1) )
nnodes=$(cat ${PBS_NODEFILE} | sort | uniq | wc -l)
nranks=$(cat ${PBS_NODEFILE} | sort | wc -l)
nranks_per_node=$((${nranks} / ${nnodes}))

[ ${nnodes} -eq 1 ] || { echo "ERROR: this test is for 1 node, but with many array jobs"; exit 1; }
echo "${nranks} ${nnodes}x${nranks_per_node}"

nsteps=$( cat inputs.txt | grep -v '#' | wc -l )

# This PBS_ARRAY_INDEX will compute multiple "steps" from inputs.txt, up to ppn
start_idx=$(( ${PBS_ARRAY_INDEX} * ${nranks_per_node} ))
stop_idx=$(( ${start_idx} + ${nranks_per_node} - 1 ))
echo "nsteps: ${nsteps}, array index: ${PBS_ARRAY_INDEX}"
echo "start_idx=${start_idx} stop_idx=${stop_idx}"

# Change to L96 directory
cd ../../models/lorenz_96_tracer_advection/

# Make a  temporary work directory for array iteration
rm -r work_test_${PBS_ARRAY_INDEX}
cp -r work work_test_${PBS_ARRAY_INDEX}
cd work_test_${PBS_ARRAY_INDEX}

# Clear any output from previous tests (if present)
rm ../../../developer_tests/tracer_filter/test_output

# Compile with mpi
./quickbuild.sh

# Create a single step obs_sequenc
./create_obs_sequence < ../../../developer_tests/tracer_filter/create_obs_sequence_input

# Generate the 1000 timestep obs_seq.in file
./create_fixed_network_seq < ../../../developer_tests/tracer_filter/create_fixed_network_seq_in

# Give execution rights for tests scripts
chmod +x ../../../developer_tests/tracer_filter/getline.sh
chmod +x ../../../developer_tests/tracer_filter/test_run.sh
chmod +x ../../../developer_tests/tracer_filter/test_cleanup.sh

# Iterate over each test to run from inputs.txt
for step in $(seq ${start_idx} ${stop_idx}); do
    # The last PBS_ARRAY_INDEX could go past nsteps if inputs.txt isn't evenly divisible by ppn
    [ ${step} -ge ${nsteps} ] && break
    # Get the command line arguments from inputs.txt for step (step counter is 0 based, so add 1)
    cmdargs=$( ./../../../developer_tests/tracer_filter/getline.sh ./../../../developer_tests/tracer_filter/inputs.txt $(( ${step} + 1)) )
    echo " PBS_ARRAY_INDEX = ${PBS_ARRAY_INDEX} launching step ${step} / args= ${cmdargs}"
    # Run test script with correct parameters (setup included)
    ./../../../developer_tests/tracer_filter/test_run.sh ${cmdargs}
done

# Wait for all the background processes to complete so PBS doesn't kill them early
wait

echo " --------------------------------------"
echo " Test array finished."

if [[ $(( ${step} + 1)) -eq $nsteps ]]; then
    echo " Cleaning up test work and output..."
    echo " --------------------------------------"

    # Navigate to test in order to clean-up temporary test directories and combine output
    cd ../work/
    ./../../../developer_tests/tracer_filter/test_cleanup.sh $(( ${PBS_ARRAY_INDEX} + 1))

    # Once tests are complete, move back to developer_tests directory and compair
    cd ../../../developer_tests/tracer_filter/
    test_out=$(diff -q test_output BASELINE_OUTPUT)

    # test_out should be an empty string if it was identical
    if [[ test_out ]]; then
    	echo " TEST FAILED: test_output differs from BASELINE_OUTPUT"
    else
    	echo " TEST PASSED: test_output is the same as BASELINE_OUTPUT"
    fi
else
    echo " --------------------------------------"
    echo " Note: Results are processed within final test array."
fi

echo " --------------------------------------"
echo " Finished ... at YYYY MM DD HH MM SS ="
dt=$(date '+%Y %m %d %H %M %S');
echo "                 $dt"
echo " --------------------------------------"
