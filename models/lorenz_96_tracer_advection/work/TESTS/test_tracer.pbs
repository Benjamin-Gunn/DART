#!/bin/bash
#PBS -N test_tracer
#PBS -j oe
#PBS -l walltime=00:10:00
## PBS_ARRAY_INDEX range, inclusive: (can be overridden by qsub command line arguments)
#PBS -J 0-3
#PBS -r y

echo " --------------------------------------"
echo " Starting ... at YYYY MM DD HH MM SS ="
dt=$(date '+%Y %m %d %H %M %S');
echo "                 $dt"
echo " Program test_tracer"
echo " --------------------------------------"

## Determine the number of nodes, and processors per node we were assigned
## (inferred based on select statement)
nodeslist=( $(cat ${PBS_NODEFILE} | sort | uniq | cut -d'.' -f1) )
nnodes=$(cat ${PBS_NODEFILE} | sort | uniq | wc -l)
nranks=$(cat ${PBS_NODEFILE} | sort | wc -l)
nranks_per_node=$((${nranks} / ${nnodes}))

[ ${nnodes} -eq 1 ] || { echo "ERROR: this example is for 1 node, but with perhaps many array steps"; exit 1; }
echo "${nranks} ${nnodes}x${nranks_per_node}"

nsteps=$( cat inputs.txt | grep -v '#' | wc -l )

# This PBS_ARRAY_INDEX will compute multiple "steps" from inputs.txt, up to ppn
start_idx=$(( ${PBS_ARRAY_INDEX} * ${nranks_per_node} ))
stop_idx=$(( ${start_idx} + ${nranks_per_node} - 1 ))
echo "nsteps: ${nsteps}, array index: ${PBS_ARRAY_INDEX}"
echo "start_idx=${start_idx} stop_idx=${stop_idx}"

# Change to work directory (one level up)
cd ../..

# Make a seperate work directory for iteration
rm -r work_test_${PBS_ARRAY_INDEX}
cp -r work work_test_${PBS_ARRAY_INDEX}
cd work_test_${PBS_ARRAY_INDEX}

# Clear any output from previous tests (if present)
rm TESTS/test_output

# Compile with mpi
./quickbuild.sh

# Create a single step obs_sequenc
./create_obs_sequence < TESTS/create_obs_sequence_input

# Generate the 1000 timestep obs_seq.in file
./create_fixed_network_seq < TESTS/create_fixed_network_seq_in

# Duplicate CSV file to iterate through
cp TESTS/one_below_qceff_table.csv .

# Give execution rights for tests scripts
chmod +x TESTS/getline.sh
chmod +x TESTS/test_run.sh

# Iterate over each test to run from inputs.txt
for step in $(seq ${start_idx} ${stop_idx}); do
    # The last PBS_ARRAY_INDEX could go past nsteps if inputs.txt isn't evenly divisible by ppn
    [ ${step} -ge ${nsteps} ] && break
    # Get the command line arguments from inputs.txt for step (step counter is 0 based, so add 1)
    cmdargs=$( ./TESTS/getline.sh ./TESTS/inputs.txt $(( ${step} + 1)) )
    echo "   PBS_ARRAY_INDEX=${PBS_ARRAY_INDEX} launching step ${step} / args=${cmdargs}"
    # Run test script with correct parameters (setup included)
    ./TESTS/test_run.sh ${cmdargs}
done

# Wait for all the background processes to complete so PBS doesn't kill them early
wait

echo "--------------------------------------"
echo

cd TESTS
diff -q test_output BASELINE_OUTPUT

if [[ $status -eq 0 ]]; then
   echo "TEST PASSED: test_output is the same as BASELINE_OUTPUT"
else
   echo "TEST FAILED: test_output differs from BASELINE_OUTPUT"
fi

echo " --------------------------------------"
echo " Finished ... at YYYY MM DD HH MM SS ="
dt=$(date '+%Y %m %d %H %M %S');
echo "                 $dt"
echo " --------------------------------------"
